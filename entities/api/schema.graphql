type Contig implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: ID!
  producingRunId: Int!
  ownerUserId: Int!
  collectionId: Int!
  sequencingRead(where: SequencingReadWhereClause = null): SequencingRead
  sequence: String!
  entityId: ID!
}

"""A connection to a list of items."""
type ContigConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ContigEdge!]!
}

"""An edge in a connection."""
type ContigEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Contig!
}

input ContigWhereClause {
  id: UUIDComparators
  producingRunId: IntComparators
  ownerUserId: IntComparators
  collectionId: IntComparators
  sequencingRead: SequencingReadWhereClause
  sequence: StrComparators
  entityId: UUIDComparators
}

type Entity {
  id: ID!
  type: String!
  producingRunId: ID!
  ownerUserId: Int!
  collectionId: Int!
}

interface EntityInterface implements Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
}

input EntityWhereClause {
  id: UUIDComparators
  entityId: UUIDComparators
  producingRunId: IntComparators
  ownerUserId: IntComparators
  collectionId: IntComparators
}

type File {
  id: ID!
  entityId: ID!
  entityFieldName: String!
  entity(where: EntityWhereClause = null): Entity
  status: FileStatus!
  protocol: String!
  namespace: String!
  path: String!
  fileFormat: String!
  compressionType: Int
  size: Int
  downloadLink(expiration: Int! = 3600): SignedURL
}

input FileCreate {
  name: String!
  fileFormat: String!
  compressionType: String = null
  protocol: String!
  namespace: String!
  path: String!
}

enum FileStatus {
  SUCCESS
  FAILED
  PENDING
}

input FileStatusEnumComparators {
  _eq: FileStatus
  _neq: FileStatus
  _in: [FileStatus!]
  _nin: [FileStatus!]
  _gt: FileStatus
  _gte: FileStatus
  _lt: FileStatus
  _lte: FileStatus
  _is_null: FileStatus
}

input FileUpload {
  name: String!
  fileFormat: String!
  compressionType: String = null
}

input FileWhereClause {
  id: UUIDComparators
  status: FileStatusEnumComparators
  protocol: StrComparators
  namespace: StrComparators
  path: StrComparators
  compressionType: StrComparators
  size: IntComparators
}

"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""
scalar GlobalID @specifiedBy(url: "https://relay.dev/graphql/objectidentification.htm")

input IntComparators {
  _eq: Int
  _neq: Int
  _in: [Int!]
  _nin: [Int!]
  _gt: Int
  _gte: Int
  _lt: Int
  _lte: Int
  _is_null: Int
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type MultipartUploadCredentials {
  protocol: String!
  namespace: String!
  path: String!
  accessKeyId: String!
  secretAccessKey: String!
  sessionToken: String!
  expiration: String!
}

type MultipartUploadResponse {
  credentials: MultipartUploadCredentials!
  file: File!
}

type Mutation {
  createSample(name: String!, location: String!, collectionId: Int!): Sample!
  createSequencingRead(nucleotide: Nucleotide!, sequence: String!, protocol: SequencingProtocol!, sequenceFileId: ID!, collectionId: Int!): SequencingRead!
  updateSample(name: String!, location: String!, entityId: ID!): Sample!
  createFile(entityId: ID!, entityFieldName: String!, file: FileCreate!): File!
  uploadFile(entityId: ID!, entityFieldName: String!, file: FileUpload!, expiration: Int! = 3600): MultipartUploadResponse!
  markUploadComplete(fileId: ID!): File!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
}

enum Nucleotide {
  RNA
  DNA
}

input NucleotideEnumComparators {
  _eq: Nucleotide
  _neq: Nucleotide
  _in: [Nucleotide!]
  _nin: [Nucleotide!]
  _gt: Nucleotide
  _gte: Nucleotide
  _lt: Nucleotide
  _lte: Nucleotide
  _is_null: Nucleotide
}

"""Information to aid in pagination."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Query {
  node(
    """The ID of the object."""
    id: GlobalID!
  ): Node!
  samples(where: SampleWhereClause = null): [Sample!]!
  sequencingReads(where: SequencingReadWhereClause = null): [SequencingRead!]!
  contigs(where: ContigWhereClause = null): [Contig!]!
  files(where: FileWhereClause = null): [File!]!
}

type Sample implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: ID!
  producingRunId: Int!
  ownerUserId: Int!
  collectionId: Int!
  name: String!
  location: String!
  sequencingReads(
    where: SequencingReadWhereClause = null

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): SequencingReadConnection!
  entityId: ID!
}

input SampleWhereClause {
  id: UUIDComparators
  producingRunId: IntComparators
  ownerUserId: IntComparators
  collectionId: IntComparators
  name: StrComparators
  location: StrComparators
  sequencingReads: SequencingReadWhereClause
  entityId: UUIDComparators
}

enum SequencingProtocol {
  MNGS
  TARGETED
  MSSPE
}

input SequencingProtocolEnumComparators {
  _eq: SequencingProtocol
  _neq: SequencingProtocol
  _in: [SequencingProtocol!]
  _nin: [SequencingProtocol!]
  _gt: SequencingProtocol
  _gte: SequencingProtocol
  _lt: SequencingProtocol
  _lte: SequencingProtocol
  _is_null: SequencingProtocol
}

type SequencingRead implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: ID!
  producingRunId: Int!
  ownerUserId: Int!
  collectionId: Int!
  nucleotide: Nucleotide!
  sequence: String!
  protocol: SequencingProtocol!
  sequenceFileId: ID!
  sequenceFile(where: FileWhereClause = null): File!
  sample(where: SampleWhereClause = null): Sample
  contigs(
    where: ContigWhereClause = null

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): ContigConnection!
  entityId: ID!
}

"""A connection to a list of items."""
type SequencingReadConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [SequencingReadEdge!]!
}

"""An edge in a connection."""
type SequencingReadEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: SequencingRead!
}

input SequencingReadWhereClause {
  id: UUIDComparators
  producingRunId: IntComparators
  ownerUserId: IntComparators
  collectionId: IntComparators
  nucleotide: NucleotideEnumComparators
  sequence: StrComparators
  protocol: SequencingProtocolEnumComparators
  sample: SampleWhereClause
  contigs: ContigWhereClause
  entityId: UUIDComparators
}

type SignedURL {
  url: String!
  protocol: String!
  method: String!
  expiration: Int!
  fields: JSON
}

input StrComparators {
  _eq: String
  _neq: String
  _in: [String!]
  _nin: [String!]
  _is_null: Int
  _gt: String
  _gte: String
  _lt: String
  _lte: String
  _like: String
  _nlike: String
  _ilike: String
  _nilike: String
  _regex: String
  _nregex: String
  _iregex: String
  _niregex: String
}

scalar UUID

input UUIDComparators {
  _eq: UUID
  _neq: UUID
  _in: [UUID!]
  _nin: [UUID!]
  _gt: UUID
  _gte: UUID
  _lt: UUID
  _lte: UUID
}
