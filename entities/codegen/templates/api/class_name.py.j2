# Auto-generated by running 'make codegen'. Do not edit.
# Make changes to the template codegen/templates/api/types/class_name.py.j2 instead.
# TODO: move to api/types/class_name.py

import uuid
import typing
from typing import Any, Mapping, Optional, Tuple

import database.models as db
import strawberry
from api.types.entities import EntityInterface
from cerbos.sdk.client import CerbosClient
from cerbos.sdk.model import Principal
from fastapi import Depends
from platformics.api.core.deps import (get_cerbos_client, get_db_session,
                                       require_auth_principal)
from platformics.api.core.gql_to_sql import (IntComparators,
                                             StrComparators, UUIDComparators)
from platformics.api.core.strawberry_extensions import DependencyExtension
from sqlalchemy.ext.asyncio import AsyncSession
from typing_extensions import TypedDict
from api.core.helpers import get_db_rows
from typing import TYPE_CHECKING, Annotated
from api.types.dataloaders import load_sequencing_reads, load_samples

E = typing.TypeVar("E", db.File, db.Entity)
T = typing.TypeVar("T")

if TYPE_CHECKING:
    {%- for related_field in cls.related_fields %}
        {%- if related_field.related_class.name not in ["File", "Entity"] %}
    from api.types.{{related_field.related_class.snake_name}} import {{related_field.related_class.name}}WhereClause, {{related_field.related_class.name}}
        {%- endif %}
    {%- endfor %}
else:
    {%- for related_field in cls.related_fields %}
        {%- if related_field.related_class.name not in ["File", "Entity"] %}
    {{related_field.related_class.name}}WhereClause = "{{related_field.related_class.name}}WhereClause"
    {{related_field.related_class.name}} = "{{related_field.related_class.name}}"
        {%- endif %}
    {%- endfor %}

@strawberry.input
class {{ cls.name }}WhereClause(TypedDict):
    id: Optional[UUIDComparators]
    producing_runid: IntComparators | None
    owner_user_id: IntComparators | None
    collection_id: IntComparators | None
    {%- for attr in cls.owned_fields %}
        {%- if attr.type == "uuid" %}
    {{ attr.name }}: Optional[UUIDComparators]
        {%- elif attr.type == "string" or attr.is_enum %}
    {{ attr.name }}: Optional[StrComparators]
        {%- elif attr.type == "integer" %}
    {{ attr.name }}: Optional[IntComparators] | None
        {%- elif attr.multivalued %}
    {{ attr.name }}: Optional[Annotated["{{ attr.type }}WhereClause", strawberry.lazy("api.types.{{ attr.type }}")]]
        {%- endif %}
    {%- endfor %}

@strawberry.type
class {{ cls.name }}(EntityInterface):
    id: uuid.UUID
    producing_runid: int
    owner_user_id: int
    collection_id: int
    {%- for attr in cls.owned_fields %}
        {%- if attr.type == "uuid" %}
    {{ attr.name }}: uuid.UUID
        {%- elif attr.type == "string" or attr.is_enum %}
    {{ attr.name }}: str
        {%- elif attr.type == "integer" %}
    {{ attr.name }}: int
        {%- elif attr.inverse %}
    {{ attr.name }}: Annotated["{{ attr.type }}", strawberry.lazy("api.types.{{ attr.type }}")] = load_{{ attr.related_class.snake_name }}s
        {%- endif %}
    {%- endfor %}

# We need to add this to each Queryable type so that strawberry will accept either our
# Strawberry type *or* a SQLAlchemy model instance as a valid response class from a resolver
{{ cls.name }}.__strawberry_definition__.is_type_of = (
    lambda obj, info: type(obj) == db.{{ cls.name }} or type(obj) == {{ cls.name }}
)

@strawberry.field(extensions=[DependencyExtension()])
async def resolve_{{ cls.name|lower }}s(
    session: AsyncSession = Depends(get_db_session, use_cache=False),
    cerbos_client: CerbosClient = Depends(get_cerbos_client),
    principal: Principal = Depends(require_auth_principal),
    where: Optional[{{ cls.name }}WhereClause] = None,
) -> typing.Sequence[{{ cls.name }}]:
    return await get_db_rows(db.{{ cls.name }}, session, cerbos_client, principal, where, [])  # type: ignore
