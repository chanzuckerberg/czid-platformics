# Auto-generated by running 'make codegen'. Do not edit.
# Make changes to the template codegen/templates/api/types/class_name.py.j2 instead.

import uuid
import typing
from typing import Any, Mapping, Optional, Tuple

import database.models as db
import strawberry
from api.types.entities import EntityInterface
from cerbos.sdk.client import CerbosClient
from cerbos.sdk.model import Principal
from fastapi import Depends
from platformics.api.core.deps import get_cerbos_client, get_db_session, require_auth_principal
from platformics.api.core.gql_to_sql import EnumComparators, IntComparators, StrComparators, UUIDComparators
from platformics.security.authorization import CerbosAction, get_resource_query
from platformics.api.core.strawberry_extensions import DependencyExtension
from sqlalchemy import ForeignKey
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy.dialects.postgresql import UUID
from strawberry.dataloader import DataLoader
from typing_extensions import TypedDict
from api.core.helpers import get_db_rows
from typing import TYPE_CHECKING, Annotated
from api.files import File
{%- for field in cls.enum_fields %}
    {%- if loop.first %}
from support.enums import 
    {%- endif %}
    {{- " " }}
    {{- field.type}}
    {{- "," if not loop.last else "" }}
{%- endfor %}

E = typing.TypeVar("E", db.File, db.Entity)
T = typing.TypeVar("T")

if TYPE_CHECKING:
    {%- for related_field in cls.related_fields %}
        {%- if related_field.related_class.name not in ["File", "Entity"] %}
    from api.types.{{related_field.related_class.snake_name}}s import {{related_field.related_class.name}}WhereClause, {{related_field.related_class.name}}
        {%- endif %}
    {%- endfor %}
else:
    {%- for related_field in cls.related_fields %}
        {%- if related_field.related_class.name not in ["File", "Entity"] %}
    {{related_field.related_class.name}}WhereClause = "{{related_field.related_class.name}}WhereClause"
    {{related_field.related_class.name}} = "{{related_field.related_class.name}}"
        {%- endif %}
    {%- endfor %}

# ------------------------------------------------------------------------------
# Dataloaders
# ------------------------------------------------------------------------------

def cache_key(key: dict) -> str:
    return key["id"]

{%- for related_field in cls.related_fields %}
    {%- if related_field.inverse and related_field.related_class.name not in ["File", "Entity"] %}
# Given a list of {{cls.name}} ids, return a list of lists, where the inner lists correspond to the
# {{related_field.name}} associated with each {{cls.name}} id.
async def batch_{{ related_field.name }}(
    keys: list[dict],
        {%- if related_field.multivalued %}
) -> typing.Sequence[Annotated["{{ related_field.type }}", strawberry.lazy("api.types.{{ related_field.name }}")]]:
        {%- else %}
) -> Optional[Annotated["{{ related_field.type }}", strawberry.lazy("api.types.{{ related_field.name }}")]]:
        {%- endif %}
    session = keys[0]["session"]
    cerbos_client = keys[0]["cerbos_client"]
    principal = keys[0]["principal"]
    ids = [key["id"] for key in keys]

    query = get_resource_query(principal, cerbos_client, CerbosAction.VIEW, db.{{ related_field.type }})
        {%- for inverse_field in related_field.related_class.related_fields if inverse_field.related_class.name == cls.name %}
            {%- if inverse_field.multivalued %}
                {%- if related_field.multivalued %}
    # The relationship is many-to-many
    # Get all {{ related_field.name }}s that are associated with at least one of the {{ cls.name }} ids
    query = query.filter(db.{{ related_field.type }}.{{cls.snake_name}}s.any(db.{{ cls.name }}.id.in_(ids)))

    all_{{ related_field.name }} = await session.execute(query)
    all_{{ related_field.name }} = all_{{ related_field.name }}.scalars().all()

    # Group the results by {{cls.name}} id
    result = []
    for id in ids:
        grouped_{{ related_field.name }} = []
        for {{ related_field.related_class.snake_name }} in all_{{ related_field.name }}:
            if id in [{{ cls.snake_name }}.id for {{ cls.snake_name }} in await {{ related_field.related_class.snake_name }}.awaitable_attrs.{{cls.snake_name}}s]:
                grouped_{{ related_field.name }}.append({{ related_field.related_class.snake_name }})
        result += [grouped_{{ related_field.name }}]
    return result
                {%- else %}
    # The relationship is many-to-one
    # Get all {{ related_field.name }}s that are associated with at least one of the {{ cls.name }} ids
    query = query.filter(db.{{ related_field.type }}.{{cls.snake_name}}s.any(db.{{ cls.name }}.id.in_(ids)))

    all_{{ related_field.name }}s = await session.execute(query)
    all_{{ related_field.name }}s = all_{{ related_field.name }}s.scalars().all()

    # Order the results by {{cls.name}} ids
    result = []
    for id in ids:
        for {{ related_field.name }} in all_{{ related_field.name }}s:
            if id in [{{ cls.snake_name }}.id for {{ cls.snake_name }} in await {{ related_field.name }}.awaitable_attrs.{{cls.snake_name}}s]:
                result.append({{ related_field.name }})
    return result
                {%- endif %}
            {%- else %}
                {%- if related_field.multivalued %}
    # The relationship is one-to-many
    # Get all {{ related_field.name }} associated with the {{ cls.name }} ids
    query = query.filter(db.{{ related_field.type }}.{{cls.snake_name}}_id.in_(ids))

    all_{{ related_field.name }} = await session.execute(query)
    all_{{ related_field.name }} = all_{{ related_field.name }}.scalars().all()

    # Group the results by {{cls.name}} id
    result = []
    for id in ids:
        grouped_{{ related_field.name }} = []
        for {{ related_field.related_class.snake_name }} in all_{{ related_field.name }}:
            if id == await {{ related_field.related_class.snake_name }}.awaitable_attrs.{{cls.snake_name}}_id:
                grouped_{{ related_field.name }}.append({{ related_field.related_class.snake_name }})
        result += [grouped_{{ related_field.name }}]
    return result
                {%- else %}
    # The relationship is one-to-one
    # Get all {{ related_field.name }} associated with the {{ cls.name }} ids
    query = query.filter(db.{{ related_field.type }}.{{cls.snake_name}}_id.in_(ids))

    all_{{ related_field.name }}s = await session.execute(query)
    all_{{ related_field.name }}s = all_{{ related_field.name }}.scalars().all()

    # Order the results by {{cls.name}} ids
    result = [next({{ related_field.name }} for {{ related_field.name }} in all_{{ related_field.name }}s if await {{ related_field.name }}.{{cls.snake_name}}_id == id) for id in ids]
    return result
                {%- endif %}
            {%- endif %}
        {%- endfor %}

{{ related_field.name }}_loader = DataLoader(load_fn=batch_{{ related_field.name }}, cache_key_fn=cache_key)


@strawberry.field(extensions=[DependencyExtension()])
    {%- if related_field.multivalued %}
async def load_{{ related_field.name }}(
    {%- else %}
async def load_{{ related_field.name }}s(
    {%- endif %}
    root: "{{ cls.name }}",
    session: AsyncSession = Depends(get_db_session, use_cache=False),
    cerbos_client: CerbosClient = Depends(get_cerbos_client),
    principal: Principal = Depends(require_auth_principal),
) -> typing.Sequence[Annotated["{{ related_field.type }}", strawberry.lazy("api.types.{{ related_field.name }}")]]:
    return await {{ related_field.name }}_loader.load(
        {"session": session, "cerbos_client": cerbos_client, "principal": principal, "id": root.id}
    )
    {%- endif %}
{%- endfor %}

# ------------------------------------------------------------------------------
# Dataloader for File object
# ------------------------------------------------------------------------------

# Given a list of {{ cls.name }} IDs for a certain file type, return related Files
def load_files_from(attr_name):
    async def batch_files(keys: list[dict]) -> Annotated["File", strawberry.lazy("api.files")]:
        session = keys[0]["session"]
        cerbos_client = keys[0]["cerbos_client"]
        principal = keys[0]["principal"]
        entity_ids = [key["id"] for key in keys]

        # Retrieve files
        query = get_resource_query(principal, cerbos_client, CerbosAction.VIEW, db.File)
        query = query.filter(
            db.File.entity_id.in_(entity_ids),
            db.File.entity_field_name == attr_name
        )
        all_files = (await session.execute(query)).scalars().all()

        # Order files so they are in the same order as `entity_ids`
        result = []
        for entity_id in entity_ids:
            matching = [f for f in all_files if f.entity_id == entity_id]
            assert len(matching) == 1
            result.append(matching[0])
        return result

    file_loader = DataLoader(load_fn=batch_files, cache_key_fn=cache_key)

    @strawberry.field(extensions=[DependencyExtension()])
    async def load_files(
        root: "{{ cls.name }}",
        session: AsyncSession = Depends(get_db_session, use_cache=False),
        cerbos_client: CerbosClient = Depends(get_cerbos_client),
        principal: Principal = Depends(require_auth_principal),
    ) -> Annotated["{{ cls.name }}", strawberry.lazy("api.files")]:
        return await file_loader.load(
            {"session": session, "cerbos_client": cerbos_client, "principal": principal, "id": root.id}
        )

    return load_files

# ------------------------------------------------------------------------------
# Define Strawberry GQL types
# ------------------------------------------------------------------------------

# Supported WHERE clause attributes
@strawberry.input
class {{ cls.name }}WhereClause(TypedDict):
    id: UUIDComparators | None
    producing_run_id: IntComparators | None
    owner_user_id: IntComparators | None
    collection_id: IntComparators | None
    {%- for attr in cls.owned_fields %}
        {%- if attr.type == "uuid" %}
    {{ attr.name }}: Optional[UUIDComparators] | None
        {%- elif attr.type == "string" %}
    {{ attr.name }}: Optional[StrComparators] | None
        {%- elif attr.is_enum %}
    {{ attr.name }}: Optional[EnumComparators[{{ attr.type }}]] | None
        {%- elif attr.type == "integer" %}
    {{ attr.name }}: Optional[IntComparators] | None
        {%- elif attr.inverse %}
            {%- if attr.multivalued %}
    {{ attr.name }}: Optional[Annotated["{{ attr.type }}WhereClause", strawberry.lazy("api.types.{{ attr.name }}")]]
            {%- else %}
    {{ attr.name }}: Optional[Annotated["{{ attr.type }}WhereClause", strawberry.lazy("api.types.{{ attr.name }}s")]]
            {%- endif%}
        {%- endif %}
    {%- endfor %}

# Define {{ cls.name }} type
@strawberry.type
class {{ cls.name }}(EntityInterface):
    id: uuid.UUID
    producing_run_id: int
    owner_user_id: int
    collection_id: int
    {%- for attr in cls.owned_fields %}
        {%- if attr.type == "uuid" %}
    {{ attr.name }}: uuid.UUID
        {%- elif attr.type == "string" %}
    {{ attr.name }}: str
        {%- elif attr.is_enum %}
    {{ attr.name }}: {{ attr.type }}
        {%- elif attr.type == "integer" %}
    {{ attr.name }}: int
        {%- elif attr.type == "File" %}
    {{ attr.name }}_id: uuid.UUID
    {{ attr.name }}: Annotated["File", strawberry.lazy("api.files")] = load_files_from("{{ attr.name }}")
        {%- elif attr.inverse %}
            {%- if attr.multivalued %}
    {{ attr.name }}: typing.Sequence[Annotated["{{ attr.type }}", strawberry.lazy("api.types.{{ attr.name }}")]] = load_{{ attr.name }}
            {%- else %}
    {{ attr.name }}: Optional[Annotated["{{ attr.type }}", strawberry.lazy("api.types.{{ attr.name }}s")]] = load_{{ attr.name }}s
            {%- endif %}
        {%- endif %}
    {%- endfor %}

# We need to add this to each Queryable type so that strawberry will accept either our
# Strawberry type *or* a SQLAlchemy model instance as a valid response class from a resolver
{{ cls.name }}.__strawberry_definition__.is_type_of = (
    lambda obj, info: type(obj) == db.{{ cls.name }} or type(obj) == {{ cls.name }}
)

# Resolvers used in api/queries
@strawberry.field(extensions=[DependencyExtension()])
async def resolve_{{ cls.snake_name|lower }}s(
    session: AsyncSession = Depends(get_db_session, use_cache=False),
    cerbos_client: CerbosClient = Depends(get_cerbos_client),
    principal: Principal = Depends(require_auth_principal),
    where: Optional[{{ cls.name }}WhereClause] = None,
) -> typing.Sequence[{{ cls.name }}]:
    return await get_db_rows(db.{{ cls.name }}, session, cerbos_client, principal, where, [])  # type: ignore
